Ejercicio 4.13

Dada una lista doblemente encadenada de enteros, ordenada en forma creciente, escriba un algoritmo que elimine las entradas repetidas. El algoritmo debe verificar al inicio que la lista que se pasa como argumento está ordenada; en caso afirmativo realizar la depuración y emitir un mensaje de 'ÉXITO'; en caso contrario, emitir un mensaje de 'ERROR'.

ACCION EJ13 (PRIM, ULT: puntero a nodo) es
Ambiente

//CREACION DEL REGISTRO
nodo= registro
   dato: entero
   ant, prox: puntero a nodo
fin registro

//FUNCION DE ORDENAMIENTO
funcion está_ordenada(cab: puntero a nodo): lógico es
	P:=cab
	Mientras *P.prox <> ULT y *p.dato <= *(*p.prox).dato hacer
	     P:=*P.prox
	fin mientras
    
    si  *p.dato <= *(*p.prox).dato entonces
        está_ordenada:=verdadero
    sino
        está_ordenada:= falso
    fin si
fin subaccion


//subaccion de eliminacion
subaccion eliminar(T:puntero a nodo) es
   	Si PRIM = T entonces   //elimina el primero
		 *(*T.SIG).ANT:=NIL;
		 PRIMERO:=*T.SIG;
	Sino          				//eliminar un nodo intermedio
	     *(*T.ANT).SIG:=*T.SIG;
		 *(*T.SIG).ANT:=*T.ANT;
	Fsi;
    disponer (T)
fin subaccion

Proceso

	//no veo de donde se declara prox, se asume cargado
    si prim = nil entonces
    	escribir(´error LISTA VACIA')
    sino
     si prim=ult entonces
        escribir('LA LISTA TIENE UN SOLO ELEMENTO POR LO TANTO NO EXISTEN ENTRADAS REPETIDAS')
     sino 	

		Si está_ordenada(prim) entonces
		 	//depurar
		   	P:=PRIM
			Mientras P <> ULT hacer
			    Si *p.dato = *(*p.prox).dato entonces
                    eliminar(p)
			    finsi
			    P:=*P.prox
			fin mientras
			// fin depurar
		   Escribir ('ÉXITO, la lista ha sido depurada')
		sino
			Escribir ('ERROR la lista no está ordenada')
		fin si
	 fin si
	fin si 

FIN ACCION